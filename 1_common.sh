sha-bang
    #! /bin/bash
    #! /bin/sh
    #! /bin/bin/python


#!/bin/rm
# Самоуничтожающийся сценарий.

: - синоним true
Бесконечный цикл
while :
do
   operation-1
   operation-2
   ...
   operation-n
done

# То же самое:
#    while true
#    do
#      ...
#    done

if condition
then :   # Никаких действий не производится и управление передается дальше
else
   take-some-action
fi


Использование неэкранированных или неокавыченных пробелов
внутри фигурных скобок недопустимо.

echo {file1,file2}\ :{\ A," B",' C'}


hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D


# Неинициализированные переменные
a=              # пустая строка. Не ноль!
let "a += 5"
echo $a         # 5
unset a
echo $a         # пустая строка



# Присваивание
for a in 7 8 9 11
do
  echo -n "$a "
done

# При использовании инструкции 'read' (тоже одна из разновидностей присваивания)
echo -n "Введите значение переменной \"a\" "
read a
echo "Значение переменной \"a\" теперь стало равным: $a."


Присваивание переменных с использованием $(...)
более современный метод, по сравнению с обратными кавычками
a=`ls -l`         # В переменную 'a' записывается результат работы команды 'ls -l'
echo $a           # Кавычки отсутствуют, удаляются лишние пробелы и пустые строки.
echo
echo "$a"         # Красивенька, как в терминале


# В баше нет типа данных
a="BB12"
b=${a/BB/77}
$b                  # 7712
let "b += 1"
$b                  # 7713

declare -i a        # Явное указание типа здесь не поможет.


# datetime
$(date +"%d_%m_%Y")
19_01_2017


# check dir existing
[ ! -d "$BAK" ] && mkdir -p "$BAK"


# \v - vertical tabulation
echo -e "a\ta"
echo -e "\v"
echo -e "a"

ABC=$'\101\102\103\010'
echo $ABC                   # ABC


# Встроенный документ
cat <<EOF
\z
EOF                         # \z



Глава 6. Завершение и код завершения
------------------------------------------------------------------------------
#!/bin/bash

echo hello
echo $?    # код возврата = 0, поскольку команда выполнилась успешно.

lskdf      # Несуществующая команда.
echo $?    # Ненулевой код возврата, поскольку команду выполнить не удалось.

echo

exit 113   # Явное указание кода возврата 113.
           # Проверить можно, если набрать в командной строке "echo $?"
           # после выполнения этого примера.



Глава 7. Проверка условий
------------------------------------------------------------------------------
Bash исполняет [[ $a -lt $b ]] как один элемент, который имеет код возврата.

if cmp a b &> /dev/null                         # Подавление вывода.
    then echo "Файлы a и b идентичны."
    else echo "Файлы a и b имеют различия."
fi


Возвращает true если...

-e файл существует

-f обычный файл (не каталог и не файл устройства)

-s ненулевой размер файла

-d файл является каталогом

-b файл является блочным устройством (floppy, cdrom и т.п.)

-c файл является символьным устройством (клавиатура, модем, звуковая
    карта и т.п.)

-p файл является каналом

-h файл является символической ссылкой

-L файл является символической ссылкой

-S файл является сокетом

-t файл (дескриптор) связан с терминальным устройством

Этот ключ может использоваться для проверки -- является ли файл
стандартным устройством ввода stdin ([ -t 0 ]) или стандартным
устройством вывода stdout ([ -t 1 ]).

-r файл доступен для чтения (пользователю, запустившему сценарий)

-w файл доступен для записи (пользователю, запустившему сценарий)

-x файл доступен для исполнения (пользователю, запустившему сценарий)

-g set-group-id (sgid) флаг для файла или каталога установлен

Если для каталога установлен флаг sgid, то файлы, создаваемые
в таком каталоге, наследуют идентификатор группы каталога, который
может не совпадать с идентификатором группы, к которой принадлежит
пользователь, создавший файл. Это может быть полезно для каталогов,
в которых хранятся файлы, общедоступные для группы пользователей.

-u set-user-id (suid) флаг для файла установлен

Установленный флаг suid приводит к изменению привилегий запущенного
процесса на привилегии владельца исполняемого файла. Исполняемые файлы,
владельцем которых является root, с установленным флагом set-user-id
запускаются с привилегиями root, даже если их запускает обычный пользователь.
[1] Это может оказаться полезным для некоторых программ (таких как pppd и
cdrecord), которые осуществляют доступ к аппаратной части компьютера.
В случае отсутствия флага suid, программы не смогут быть запущены рядовым
пользователем, не обладающим привилегиями root.

             -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd

Файл с установленным флагом suid отображается с включенным флагом s в поле
прав доступа.

-k флаг sticky bit (бит фиксации) установлен

Общеизвестно, что флаг "sticky bit" -- это специальный тип прав доступа к
файлам. Программы с установленным флагом "sticky bit" остаются в системном
кэше после своего завершения, обеспечивая тем самым более быстрый запуск
программы. [2] Если флаг установлен для каталога, то это приводит к
ограничению прав на запись. Установленный флаг "sticky bit" отображается
в виде символа t в поле прав доступа.

             drwxrwxrwt    7 root         1024 May 19 21:26 tmp/

Если пользователь не является владельцем каталога, с установленным
"sticky bit", но имеет право на запись в каталог, то он может удалять
только те файлы в каталоге, владельцем которых он является.
Это предотвращает удаление и перезапись "чужих" файлов в общедоступных
каталогах, таких как /tmp.

-O вы являетесь владельцем файла

-G вы принадлежите к той же группе, что и файл

-N файл был модифицирован с момента последнего чтения

f1 -nt f2 файл f1 более новый, чем f2

f1 -ot f2 файл f1 более старый, чем f2

f1 -ef f2 файлы f1 и f2 являются "жесткими" ссылками на один и тот же файл

! "НЕ" -- логическое отрицание (инверсия).
------------------------------------------------------------------------------


Операции сравнения

сравнение целых чисел
[ "$a" -eq "$b" ]

(("$a" < "$b"))


AND OR
Они похожи на операторы Bash && и ||
[[ condition1 && condition2 ]]
Операторы -o и -a употребляются совместно с командой test
или внутри одинарных квадратных скобок.
if [ "$exp1" -a "$exp2" ]

------------------------------------------------------------------------------




Глава 8. Операции и смежные темы
------------------------------------------------------------------------------
let "var += 5"
    -=
    *=
    /=
    %=
    **= - ERROR

"expr 10 < 9"   # 0
"expr 10 > 9"   # 1


if [ $condition1 ] && [ $condition2 ]
# То же самое, что:  if [ $condition1 -a $condition2 ]
# Возвращает true если оба операнда condition1 и condition2 истинны...

if [[ $condition1 && $condition2 ]]    # То же верно
# Обратите внимание: оператор && не должен использоваться внутри [ ... ].


# Запятая
let "t2 = ((a = 9, 15 / 3))"
echo "t2 = $t2    a = $a"       # t2 = 5    a = 9


0       - восьмеричные          (oct)
0х      - шестнадцатиричные     (hex)
ОСНОВА#ЧИСЛО.


$# Количество аргументов командной строки

$* Все аргументы в виде одной строки (слова)

$@ То же самое, что и $*, но при этом каждый параметр
    представлен как отдельная строка (слово)





9.2. Работа со строками
------------------------------------------------------------------------------
stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringZ`      # 15
echo `expr "$stringZ" : '.*'`    # 15


echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8


echo `expr index "$stringZ" C12`             # 6

echo `expr index "$stringZ" 1c`              # 3
# символ 'c' (в #3 позиции) совпал раньше, чем '1'.



stringZ=abcABC123ABCabc
#       |----|
#       |----------|

echo ${stringZ#a*C}      # 123ABCabc
# Удаление самой короткой подстроки.

echo ${stringZ##a*C}     # abc
# Удаление самой длинной подстроки.


stringZ=abcABC123ABCabc
#                    ||
#        |------------|

echo ${stringZ%b*c}      # abcABC123ABCa

echo ${stringZ%%b*c}     # a








------------------------------------------------------------------------------




echo "username1 = ${username1-`whoami`}" # default value if exist
echo "username2 = ${username2:-`whoami`}" # default value anyway


$ q=
$ ${q?err_msg}
$ ${q:?err_msg}
bash: q: err_msg

$ ${w?}
bash: w: parameter null or not set
$ ${w}
$

# Удаление из переменной
# ${var#Pattern}, ${var##Pattern}  - с начала строки
# ${var%Pattern}, ${var%%Pattern}  - с конца строки
echo `basename $PWD`        # Имя текущего рабочего каталога.
echo "${PWD##*/}"           # Имя текущего рабочего каталога.
echo
echo `basename $0`          # Имя файла-сценария.
echo $0                     # Имя файла-сценария.
echo "${0##*/}"             # Имя файла-сценария.
echo
filename=test.data
echo "${filename##*.}"      # data
                            # Расширение файла.

____________________________________________________
Изменение расширений в именах файлов:

#!/bin/bash
# Изменение расширений в именах файлов.
#
#         rfe old_extension new_extension
#
# Пример:
# Изменить все расширения *.gif в именах файлов на *.jpg, в текущем каталоге
#          rfe gif jpg

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Порядок использования: `basename $0` old_file_suffix new_file_suffix"
  exit $E_BADARGS
fi

for filename in *.$1
# Цикл прохода по списку имен файлов, имеющих расширение равное первому аргументу.
do
  mv $filename ${filename%$1}$2
  #  Удалить первое расширение и добавить второе,
done

exit 0
____________________________________________________



Поиск по шаблону всех, ранее объявленных переменных,
имена которых начинаются c "H"

$ echo ${!H*}
$ echo ${!H@}

${var/#Pattern/Replacement}
Если в переменной var найдено совпадение с Pattern,
причем совпадающая подстрока расположена в начале
строки (префикс), то оно заменяется на Replacement.

${var/%Pattern/Replacement}
Если в переменной var найдено совпадение с Pattern,
причем совпадающая подстрока расположена в конце
строки (суффикс), то оно заменяется на Replacement.








